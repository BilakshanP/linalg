## Creation of Main Module and Defining Constants, Functions, Sub-Modules and More

###### Note: Main module creation must be done before defining anything else.

+ ### [Modules](1.1.0_modules.md)
+ ### [Constants](1.1.0_constants.md)
+ ### [Functions](1.3.0.functions.md)
+ ### [Classes](1.4.0.classes.md)

+ ### Main Module
    This is the minimal viable code required for the creation of main module:

    ```rust
    use prelude::*;
    
    #[pymodule]
    fn linalg(_py: Python, m: &PyModule) -> PyResult<()> {
        Ok(())
    }
    ```

+ ### Defining Constants
    ```rust
    use prelude::*;
    
    #[pymodule]
    fn linalg(_py: Python, m: &PyModule) -> PyResult<()> {
        m.add("PI", std::f64::consts::PI); // linalg.PI: float
        m.add("alphabets", (b'a'..=b'z').map(|ord: u8| ord as char).collect::<String>())?; // linalg.alphabets: str

        Ok(())
    }
    ```

+ ### Defining Functions
    ```rust
    use prelude::*;

    /// linalg.reverse_string(s: str) -> str
    #[pyfunction]
    fn reverse_string(s: &str) -> PyResult<String> {
        Ok(s.chars().rev().collect())
    }

    /// linalg.print_sum(m: int, n: int) -> None
    #[pyfunction]
    #[pyo3(name="print_sum")]
    fn print_as_sum(m: f64, n: f64) {
        println!("{} + {} = {}", m, n, m + n);
    }

    /// linalg.print_and_return_sum(m: int, n: int) -> int
    #[pyfunction]
    #[pyo3(name="print_and_return_sum")]
    fn print_and_return(m: f64, n: f64) {
        let sum = m + n;
    
        println!("{} + {} = {}", m, n, sum);

        sum
    }

    #[pymodule]
    fn linalg(_py: Python, m: &PyModule) -> PyResult<()> {
        m.add_function(wrap_pyfunction!(reverse_string, m)?)?;

        insert_functions!(m, print_as_sum, print_and_return);

        Ok(())
    }
    ```

+ ### Defining Sub-Modules
    ```rust
    /// linalg.mod_out_1
    #[pymodule]
    #[pyo3(name="mod_out_1")]
    fn module_outside_1(_py: Python, m: &PyModule) -> PyResult<()> {
        m.add_function(wrap_pyfunction!(some_function, m)?)?;
        insert_functions(m, other_function, one_more_function);

        Ok(())
    }

    /// linalg.mod_out_2
    #[pymodule]
    #[pyo3(name="mod_out_2")]
    fn module_outside_2(_py: Python, m: &PyModule) -> PyResult<()> {
        m.add_function(wrap_pyfunction!(some_function, m)?)?;
        insert_functions(m, other_function, one_more_function);

        Ok(())
    }

    #[pymodule]
    fn linalg(_py: Python, m: &PyModule) -> PyResult<()> {
        m.add_wrapped(wrap_pymodule!(module_outside_1))?;
        insert_submodules!(m, module_ouside_2);

        let module_in = PyModule::new(_py, "mod_in")?;
        module_in.add_function(wrap_pyfunction!(some_function, module_in)?)?;
        insert_functions!(module_in, other_function);

        m.add_submodule(module_in)?;

        Ok(())
    }
    ```